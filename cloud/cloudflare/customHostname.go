package cloudflare

import (
	"errors"
	"fmt"
	"time"

	"github.com/farseer-go/fs/snc"
	"github.com/farseer-go/utils/http"
)

// Cloudflare客户端
type CustomHostnameClient struct {
	cli    *Client
	ZoneId string
}

// 缓存dcv uuid，避免重复请求，同一个zoneId只请求1次
var mDcvUuidCache = make(map[string]string)

// 缓存自定义主机ID，避免重复请求
var mCustomHostNameIdCache = make(map[string]string)

func (receiver *Client) NewCustomHostnameClient(zoneId string) *CustomHostnameClient {
	return &CustomHostnameClient{
		cli:    receiver,
		ZoneId: zoneId,
	}
}

type CustomHostnames struct {
	Result []struct {
		ID       string `json:"id"`
		Hostname string `json:"hostname"`
		Ssl      struct {
			ID                string   `json:"id"`
			Type              string   `json:"type"`
			Method            string   `json:"method"`
			Status            string   `json:"status"`
			Hosts             []string `json:"hosts"`
			TxtName           string   `json:"txt_name"`
			TxtValue          string   `json:"txt_value"`
			ValidationRecords []struct {
				Status   string `json:"status"`
				TxtName  string `json:"txt_name"`
				TxtValue string `json:"txt_value"`
			} `json:"validation_records"`
			DcvDelegationRecords []DcvDelegationRecords `json:"dcv_delegation_records"`
			Settings             struct {
				MinTLSVersion string `json:"min_tls_version"`
			} `json:"settings"`
			BundleMethod string `json:"bundle_method"`
			Certificates []struct {
				Issuer            string    `json:"issuer"`
				SerialNumber      string    `json:"serial_number"`
				Signature         string    `json:"signature"`
				ExpiresOn         time.Time `json:"expires_on"`
				IssuedOn          time.Time `json:"issued_on"`
				FingerprintSha256 string    `json:"fingerprint_sha256"`
				ID                string    `json:"id"`
			} `json:"certificates"`
			Wildcard             bool   `json:"wildcard"`
			CertificateAuthority string `json:"certificate_authority"`
		} `json:"ssl"`
		Status    string    `json:"status"`
		CreatedAt time.Time `json:"created_at"`
	} `json:"result"`
	ResultInfo struct {
		Page       int `json:"page"`
		PerPage    int `json:"per_page"`
		Count      int `json:"count"`
		TotalCount int `json:"total_count"`
		TotalPages int `json:"total_pages"`
	} `json:"result_info"`
	Success  bool            `json:"success"`
	Errors   []MessageStatus `json:"errors"`
	Messages []MessageStatus `json:"messages"`
}

// 获取自定义主机列表
func (receiver *CustomHostnameClient) List(search string, pageSize, pageIndex int) (CustomHostnames, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/custom_hostnames \
	// -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
	// -H "X-Auth-Key: $CLOUDFLARE_API_KEY"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/custom_hostnames?per_page=%d&page=%d&hostname=%s", receiver.ZoneId, pageSize, pageIndex, search)
	resultJson, _, _, err := http.RequestProxyConfigure("GET", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	var customHostnames CustomHostnames
	snc.Unmarshal([]byte(resultJson), &customHostnames)

	// 缓存自定义主机ID
	for _, customHostname := range customHostnames.Result {
		mCustomHostNameIdCache[customHostname.Hostname] = customHostname.ID
	}
	return customHostnames, err
}

type OwnershipVerification struct {
	Type  string `json:"type"`
	Name  string `json:"name"`
	Value string `json:"value"`
}
type DcvDelegationRecords struct {
	Cname       string `json:"cname"`
	CnameTarget string `json:"cname_target"`
}

// 获取自定义主机列表
func (receiver *CustomHostnameClient) Create(hostname string) (bool, string, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/custom_hostnames \
	// 	-H 'Content-Type: application/json' \
	// 	-H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
	// 	-H "X-Auth-Key: $CLOUDFLARE_API_KEY" \
	// 	-d '{
	// 		"hostname": "app.example.com",
	// 		"ssl": {}
	// 		}'

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/custom_hostnames", receiver.ZoneId)
	body := map[string]any{
		"hostname": hostname,
		"ssl": map[string]any{
			"bundle_method": "ubiquitous",
			"wildcard":      false,
			"method":        "txt",
			"type":          "dv",
		},
	}
	resultJson, _, _, err := http.RequestProxyConfigure("POST", url, map[string]any{"Authorization": receiver.cli.ApiToken}, body, "application/json", 2000)

	type AutoGenerated struct {
		Result struct {
			ID                        string                `json:"id"`
			Hostname                  string                `json:"hostname"`
			Ssl                       interface{}           `json:"ssl"`
			Status                    string                `json:"status"`
			OwnershipVerification     OwnershipVerification `json:"ownership_verification"`
			OwnershipVerificationHTTP struct {
				HTTPURL  string `json:"http_url"`
				HTTPBody string `json:"http_body"`
			} `json:"ownership_verification_http"`
			CreatedAt time.Time `json:"created_at"`
		} `json:"result"`
		Success  bool            `json:"success"`
		Errors   []MessageStatus `json:"errors"`
		Messages []MessageStatus `json:"messages"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	// 特殊处理：如果记录已存在，则返回已存在的记录
	if len(result.Errors) > 0 && result.Errors[0].Code == 1406 {
		return true, "", err
	}

	if len(result.Errors) > 0 {
		return result.Success, result.Result.ID, errors.New(result.Errors[0].Message)
	}

	// 缓存自定义主机ID
	mCustomHostNameIdCache[hostname] = result.Result.ID

	if len(result.Messages) > 0 {
		return result.Success, result.Result.ID, err
	}

	return result.Success, result.Result.ID, err
}

type CustomHostnameDetial struct {
	Result struct {
		ID       string `json:"id"`
		Hostname string `json:"hostname"`
		Ssl      struct {
			ID                string `json:"id"`
			Type              string `json:"type"`
			Method            string `json:"method"`
			Status            string `json:"status"`
			TxtName           string `json:"txt_name"`
			TxtValue          string `json:"txt_value"`
			ValidationRecords []struct {
				Status   string `json:"status"`
				TxtName  string `json:"txt_name"`
				TxtValue string `json:"txt_value"`
			} `json:"validation_records"`
			DcvDelegationRecords []struct {
				Cname       string `json:"cname"`
				CnameTarget string `json:"cname_target"`
			} `json:"dcv_delegation_records"`
			Settings struct {
				MinTLSVersion string `json:"min_tls_version"`
			} `json:"settings"`
			BundleMethod         string `json:"bundle_method"`
			Wildcard             bool   `json:"wildcard"`
			CertificateAuthority string `json:"certificate_authority"`
		} `json:"ssl"`
		Status    string    `json:"status"`
		CreatedAt time.Time `json:"created_at"`
	} `json:"result"`
	Success  bool            `json:"success"`
	Errors   []MessageStatus `json:"errors"`
	Messages []MessageStatus `json:"messages"`
}

// 获取自定义主机详情
func (receiver *CustomHostnameClient) Info(customHostnameId string) (CustomHostnameDetial, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/custom_hostnames/$CUSTOM_HOSTNAME_ID \
	// -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
	// -H "X-Auth-Key: $CLOUDFLARE_API_KEY"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/custom_hostnames/%s", receiver.ZoneId, customHostnameId)
	resultJson, _, _, err := http.RequestProxyConfigure("GET", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	var result CustomHostnameDetial
	snc.Unmarshal([]byte(resultJson), &result)

	return result, err
}

func (receiver *CustomHostnameClient) Delete(customHostnameId string) (bool, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/custom_hostnames/$CUSTOM_HOSTNAME_ID \
	// -X DELETE \
	// -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
	// -H "X-Auth-Key: $CLOUDFLARE_API_KEY"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/custom_hostnames/%s", receiver.ZoneId, customHostnameId)
	resultJson, _, _, err := http.RequestProxyConfigure("DELETE", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	type AutoGenerated struct {
		Result   interface{}     `json:"result"`
		Success  bool            `json:"success"`
		Errors   []MessageStatus `json:"errors"`
		Messages []MessageStatus `json:"messages"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	return result.Success, err
}

// 删除自定义主机（通过主机名删除）
func (receiver *CustomHostnameClient) DeleteByHostName(hostname string) (bool, error) {
	// 通过缓存获取自定义主机ID
	customHostnameId := mCustomHostNameIdCache[hostname]
	if customHostnameId == "" {
		// 如果缓存没有，则通过API获取
		customHostnames, err := receiver.List(hostname, 100, 1)
		if err != nil {
			return false, err
		}
		for _, customHostname := range customHostnames.Result {
			if customHostname.Hostname == hostname {
				customHostnameId = customHostname.ID
				break
			}
		}
		if customHostnameId == "" {
			return false, errors.New("未找到自定义主机ID")
		}
	}

	return receiver.Delete(customHostnameId)
}

// 获取dcv的uuid
func (receiver *CustomHostnameClient) GetDcvUuid() (string, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dcv_delegation/uuid \
	// -H "X-Auth-Email: $CLOUDFLARE_EMAIL" \
	// -H "X-Auth-Key: $CLOUDFLARE_API_KEY"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dcv_delegation/uuid", receiver.ZoneId)
	resultJson, _, _, err := http.RequestProxyConfigure("GET", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	type AutoGenerated struct {
		Success  bool          `json:"success"`
		Errors   []interface{} `json:"errors"`
		Messages []interface{} `json:"messages"`
		Result   struct {
			UUID string `json:"uuid"`
		} `json:"result"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	return result.Result.UUID, err
}

type DcvCName struct {
	Uuid  string
	Type  string
	Name  string
	Value string
}

// 得到Dcv CNAME记录的值
func (receiver *CustomHostnameClient) GetDcvCName(hostName string) DcvCName {
	// 通过api读取uuid
	if mDcvUuidCache[receiver.ZoneId] == "" {
		mDcvUuidCache[receiver.ZoneId], _ = receiver.GetDcvUuid()
	}
	// _acme-challenge.<hostname> CNAME <hostname>.uuid.dcv.cloudflare.com
	return DcvCName{
		Uuid:  mDcvUuidCache[receiver.ZoneId],
		Type:  "CNAME",
		Name:  fmt.Sprintf("_acme-challenge.%s", hostName),
		Value: fmt.Sprintf("%s.%s.dcv.cloudflare.com", hostName, mDcvUuidCache[receiver.ZoneId]),
	}
}
