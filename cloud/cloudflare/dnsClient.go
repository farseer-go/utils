package cloudflare

import (
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/farseer-go/fs/snc"
	"github.com/farseer-go/utils/http"
)

// Cloudflare客户端
type DnsClient struct {
	cli    *Client
	ZoneId string
}

// 缓存dnsId，避免重复请求，同一个dnsId只请求1次
var mDnsIdCache = make(map[string]string)

func (receiver *Client) NewDnsClient(zoneId string) *DnsClient {
	return &DnsClient{
		cli:    receiver,
		ZoneId: zoneId,
	}
}

type MessageStatus struct {
	Code             int    `json:"code"`              // 状态码 1000
	Message          string `json:"message"`           // 错误信息 "DNS Record not found"
	DocumentationURL string `json:"documentation_url"` // 文档链接 "https://api.cloudflare.com/#dns-records-for-a-zone-dns-record-details"
	Source           struct {
		Pointer string `json:"pointer"` // 指针 "/zones/zone_identifier/dns_records/dns_record_identifier"
	} `json:"source"`
}

type Dnss struct {
	Result []struct {
		ID        string `json:"id"`        // 记录ID xxxxxxxxxxxxxxxxxxxxxx
		Name      string `json:"name"`      // 记录名称 www.example.com
		Type      string `json:"type"`      // 记录类型 A
		Content   string `json:"content"`   // 记录内容 127.0.0.1
		Proxiable bool   `json:"proxiable"` // 是否可代理 true
		Proxied   bool   `json:"proxied"`   // 是否已代理 false
		TTL       int    `json:"ttl"`       // 生存时间 3600
		Settings  struct {
		} `json:"settings"`
		Meta struct {
		} `json:"meta"`
		Comment    interface{}   `json:"comment"`     // 记录备注 nil
		Tags       []interface{} `json:"tags"`        // 记录标签 []
		CreatedOn  time.Time     `json:"created_on"`  // 创建时间
		ModifiedOn time.Time     `json:"modified_on"` // 修改时间
	} `json:"result"`
	Success    bool            `json:"success"`  // 是否成功 true
	Errors     []MessageStatus `json:"errors"`   // 错误信息 []
	Messages   []MessageStatus `json:"messages"` // 消息信息 []
	ResultInfo struct {
		Page       int `json:"page"`        // 当前页码 1
		PerPage    int `json:"per_page"`    // 每页数量 20
		TotalPages int `json:"total_pages"` // 总页数 1
		Count      int `json:"count"`       // 当前页数量 1
		TotalCount int `json:"total_count"` // 总数量 1
	} `json:"result_info"`
}

// 查询指定域名的DNS记录列表
func (receiver *DnsClient) List(search string, pageSize, pageIndex int) (Dnss, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records \
	// -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dns_records?per_page=%d&page=%d", receiver.ZoneId, pageSize, pageIndex)
	if search != "" {
		url += fmt.Sprintf("&name=%s", search)
	}
	resultJson, _, _, err := http.RequestProxyConfigure("GET", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	var dnss Dnss
	snc.Unmarshal([]byte(resultJson), &dnss)

	// 缓存dnsId，避免重复请求
	for _, dns := range dnss.Result {
		mDnsIdCache[dns.Name] = dns.ID
	}
	return dnss, err
}

// 添加一条dns记录
func (receiver *DnsClient) Create(recordType string, domain string, ipOrContent string, proxied bool, ttl int, comment string, ifExistsThenUpdate bool) (bool, string, int, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records \
	// -H 'Content-Type: application/json' \
	// -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
	// -d '{
	//       "name": "example.com",
	//       "ttl": 3600,
	//       "type": "A",
	//       "comment": "Domain verification record",
	//       "content": "127.0.0.1",
	//       "proxied": true
	//     }'

	// cf要求，txt记录内容必须用引号包裹
	if strings.Compare(recordType, "txt") == 0 && ipOrContent[0] != '"' && ipOrContent[len(ipOrContent)-1] != '"' {
		ipOrContent = fmt.Sprintf(`"%s"`, ipOrContent)
	}

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dns_records", receiver.ZoneId)
	body := map[string]any{
		"name":    domain,
		"ttl":     ttl,
		"type":    recordType,
		"comment": comment,
		"content": ipOrContent,
		"proxied": proxied,
	}
	resultJson, _, _, err := http.RequestProxyConfigure("POST", url, map[string]any{"Authorization": receiver.cli.ApiToken}, body, "application/json", 2000)

	type AutoGenerated struct {
		Errors   []MessageStatus `json:"errors"`
		Messages []MessageStatus `json:"messages"`
		Success  bool            `json:"success"`
		Result   struct {
			Name     string `json:"name"`
			TTL      int    `json:"ttl"`
			Type     string `json:"type"`
			Comment  string `json:"comment"`
			Content  string `json:"content"`
			Proxied  bool   `json:"proxied"`
			Settings struct {
				Ipv4Only bool `json:"ipv4_only"`
				Ipv6Only bool `json:"ipv6_only"`
			} `json:"settings"`
			Tags      []string  `json:"tags"`
			ID        string    `json:"id"`
			CreatedOn time.Time `json:"created_on"`
			Meta      struct {
			} `json:"meta"`
			ModifiedOn        time.Time `json:"modified_on"`
			Proxiable         bool      `json:"proxiable"`
			CommentModifiedOn time.Time `json:"comment_modified_on"`
			TagsModifiedOn    time.Time `json:"tags_modified_on"`
		} `json:"result"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	// 特殊处理：如果记录已存在，则更新或直接返回成功
	if len(result.Errors) > 0 && result.Errors[0].Code == 81053 {
		// 查询现有记录ID
		listResult, _ := receiver.List(domain, 100, 1)
		for _, record := range listResult.Result {
			mDnsIdCache[record.Name] = record.ID

			// 如果记录一样，则直接返回成功
			if record.Type == recordType && record.Content == ipOrContent && record.Proxied == proxied {
				return true, record.ID, 0, nil
			}

			// 更新现有记录
			if ifExistsThenUpdate {
				// 更新现有记录
				success, codeStatus, err := receiver.Update(record.ID, recordType, domain, ipOrContent, proxied, ttl, comment)
				return success, record.ID, codeStatus, err
			}
		}
	}

	if len(result.Errors) > 0 {
		return result.Success, result.Result.ID, result.Errors[0].Code, errors.New(result.Errors[0].Message)
	}

	mDnsIdCache[domain] = result.Result.ID
	if len(result.Messages) > 0 {
		return result.Success, result.Result.ID, result.Messages[0].Code, err
	}

	return result.Success, result.Result.ID, 0, err
}

// 更新一条dns记录
func (receiver *DnsClient) Update(recordId string, recordType string, domain string, ipOrContent string, proxied bool, ttl int, comment string) (bool, int, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$DNS_RECORD_ID \
	// -X PATCH \
	// -H 'Content-Type: application/json' \
	// -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN" \
	// -d '{
	//       "name": "example.com",
	//       "ttl": 3600,
	//       "type": "A",
	//       "comment": "Domain verification record",
	//       "content": "127.0.0.1",
	//       "proxied": true
	//     }'

	// cf要求，txt记录内容必须用引号包裹
	if strings.Compare(recordType, "txt") == 0 && ipOrContent[0] != '"' && ipOrContent[len(ipOrContent)-1] != '"' {
		ipOrContent = fmt.Sprintf(`"%s"`, ipOrContent)
	}

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dns_records/%s", receiver.ZoneId, recordId)
	body := map[string]any{
		"name":    domain,
		"ttl":     ttl,
		"type":    recordType,
		"comment": comment,
		"content": ipOrContent,
		"proxied": proxied,
	}
	resultJson, _, _, err := http.RequestProxyConfigure("PATCH", url, map[string]any{"Authorization": receiver.cli.ApiToken}, body, "application/json", 2000)

	type AutoGenerated struct {
		Errors   []MessageStatus `json:"errors"`
		Messages []MessageStatus `json:"messages"`
		Success  bool            `json:"success"`
		Result   struct {
			Name     string `json:"name"`
			TTL      int    `json:"ttl"`
			Type     string `json:"type"`
			Comment  string `json:"comment"`
			Content  string `json:"content"`
			Proxied  bool   `json:"proxied"`
			Settings struct {
				Ipv4Only bool `json:"ipv4_only"`
				Ipv6Only bool `json:"ipv6_only"`
			} `json:"settings"`
			Tags      []string  `json:"tags"`
			ID        string    `json:"id"`
			CreatedOn time.Time `json:"created_on"`
			Meta      struct {
			} `json:"meta"`
			ModifiedOn        time.Time `json:"modified_on"`
			Proxiable         bool      `json:"proxiable"`
			CommentModifiedOn time.Time `json:"comment_modified_on"`
			TagsModifiedOn    time.Time `json:"tags_modified_on"`
		} `json:"result"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	if len(result.Errors) > 0 {
		return result.Success, result.Errors[0].Code, errors.New(result.Errors[0].Message)
	}

	mDnsIdCache[domain] = recordId
	if len(result.Messages) > 0 {
		return result.Success, result.Messages[0].Code, err
	}

	return result.Success, 0, err
}

// 删除一条dns记录
func (receiver *DnsClient) Delete(recordId string) (string, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$DNS_RECORD_ID \
	// -X DELETE \
	// -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dns_records/%s", receiver.ZoneId, recordId)
	resultJson, _, _, err := http.RequestProxyConfigure("DELETE", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	type AutoGenerated struct {
		Result struct {
			ID string `json:"id"`
		} `json:"result"`
	}
	var result AutoGenerated
	snc.Unmarshal([]byte(resultJson), &result)

	return result.Result.ID, err
}

// 根据域名删除dns记录（自动获取dnsId）
func (receiver *DnsClient) DeleteByDomain(domain string) (string, error) {
	dnsId, err := receiver.GetDnsIdByDomain(domain)
	if err != nil {
		return "", err
	}
	return receiver.Delete(dnsId)
}

type DnsDetial struct {
	Errors   []MessageStatus `json:"errors"`
	Messages []MessageStatus `json:"messages"`
	Success  bool            `json:"success"` // 是否成功 true
	Result   struct {
		ID                string    `json:"id"`                  // 记录ID xxxxxxxxxxxxxxxxxxxxxx
		Name              string    `json:"name"`                // 记录名称 www.example.com
		TTL               int       `json:"ttl"`                 // 生存时间 3600
		Type              string    `json:"type"`                // 记录类型 A
		Comment           string    `json:"comment"`             // 记录备注 Domain verification record
		Content           string    `json:"content"`             // 记录内容
		Proxied           bool      `json:"proxied"`             // 是否已代理 false
		Proxiable         bool      `json:"proxiable"`           // 是否可代理 true
		Tags              []string  `json:"tags"`                // 记录标签 []
		CreatedOn         time.Time `json:"created_on"`          // 创建时间 2020-01-01T12:00:00Z
		ModifiedOn        time.Time `json:"modified_on"`         // 修改时间 2020-01-02T12:00:00Z
		CommentModifiedOn time.Time `json:"comment_modified_on"` // 备注修改时间
		TagsModifiedOn    time.Time `json:"tags_modified_on"`    // 标签修改时间
		Settings          struct {
			Ipv4Only bool `json:"ipv4_only"` // 仅IPv4 false
			Ipv6Only bool `json:"ipv6_only"` // 仅IPv6 false
		} `json:"settings"`
		Meta struct {
		} `json:"meta"`
	} `json:"result"`
}

func (receiver *DnsClient) Info(recordId string) (DnsDetial, error) {
	// curl https://api.cloudflare.com/client/v4/zones/$ZONE_ID/dns_records/$DNS_RECORD_ID \
	// -H "Authorization: Bearer $CLOUDFLARE_API_TOKEN"

	url := fmt.Sprintf("https://api.cloudflare.com/client/v4/zones/%s/dns_records/%s", receiver.ZoneId, recordId)
	resultJson, _, _, err := http.RequestProxyConfigure("GET", url, map[string]any{"Authorization": receiver.cli.ApiToken}, nil, "application/json", 2000)

	var result DnsDetial
	snc.Unmarshal([]byte(resultJson), &result)

	return result, err
}

// 根据域名获取dnsId
func (receiver *DnsClient) GetDnsIdByDomain(domain string) (string, error) {
	// 先从缓存获取
	if dnsId, exists := mDnsIdCache[domain]; exists && dnsId != "" {
		return dnsId, nil
	}
	listResult, err := receiver.List(domain, 100, 1)
	for _, record := range listResult.Result {
		mDnsIdCache[record.Name] = record.ID
	}

	return mDnsIdCache[domain], err
}
